use log::info;
use std::fs;
use std::fs::File;
use std::io::{self, Write};
use std::process::{Command, Output};

fn main() -> io::Result<()> {
    env_logger::init();

    // TODO try and write to grab the commands from Clap at some point
    let commands_with_subcommands = vec![
        (
            "../../target/release/nym-api",
            vec!["init", "run", "build-info"],
        ),
        (
            "../../target/release/nym-client",
            vec![
                "init",
                "run",
                "import-credential",
                "list-gateways",
                "switch-gateway",
                "build-info",
                "completions",
                "generate-fig-spec",
            ],
        ),
        (
            "../../target/release/nym-socks5-client",
            vec![
                "init",
                "run",
                "import-credential",
                "list-gateways",
                "add-gateway",
                "build-info",
                "completions",
                "generate-fig-spec",
            ],
        ),
        (
            "../../target/release/nym-node",
            vec![
                "build-info",
                "bonding-information",
                "node-details",
                "migrate",
                "run",
                "sign",
            ],
        ),
        (
            "../../target/release/nymvisor",
            vec![
                "init",
                "run",
                "build-info",
                "daemon-build-info",
                "add-upgrade",
                "config",
            ],
        ),
    ];

    for (main_command, subcommands) in commands_with_subcommands {
        let last_word = get_last_word_from_filepath(main_command);
        info!("{last_word:#?}");

        if !fs::metadata("./autodoc/")
            .map(|metadata| metadata.is_dir())
            .unwrap_or(false)
        {
            fs::create_dir_all("./autodoc/")?;
        }

        let mut file = File::create(format!("autodoc/{}.md", last_word.unwrap()))?;
        writeln!(
            file,
            "# {} Binary Commands",
            format!("`{}`", last_word.unwrap())
        )?;
        writeln!(
            file,
            "\nThese docs are autogenerated by the `autodocs` script. 
            \n**TODO add link**"
        )?;
        let output = Command::new(main_command).arg("--help").output()?;
        write_output_to_file(&mut file, output)?;
        for subcommand in subcommands {
            execute_command(&mut file, main_command, subcommand)?;
        }
    }
    Ok(())
}

fn get_last_word_from_filepath(filepath: &str) -> Option<&str> {
    let parts: Vec<&str> = filepath.split('/').collect();
    parts.last().copied()
}

fn execute_command(file: &mut File, main_command: &str, subcommand: &str) -> io::Result<()> {
    // title
    writeln!(file, "\n### `{}`", subcommand)?;

    // first execute the command with `--help`
    info!("executing {} {} --help ", main_command, subcommand);
    let output = Command::new(main_command)
        .arg(subcommand)
        .arg("--help")
        .output()?;
    if !output.stdout.is_empty() {
        write_output_to_file(file, output)?;
    } else {
        info!("empty stdout - nothing to write");
    }

    // then execute w/out help: the majority of functions will fail since you're not passing
    // required params but thats fine as we can just not render stderr into the final file.
    //
    // this check is basically checking for the rare commands (rn just one) that start a process with no params
    // perhaps if this list grows we could just add a timeout and shunt the running and writing
    // into a thread with a timeout or something but for right now its fine / thats overkill
    if get_last_word_from_filepath(main_command).unwrap() == "nym-node"
        || get_last_word_from_filepath(main_command).unwrap() == "nym-api" && subcommand == "run"
    {
        info!("SKIPPING {} {}", main_command, subcommand);
    } else {
        info!("executing {} {}", main_command, subcommand);
        let output = Command::new(main_command).arg(subcommand).output()?;
        if !output.stdout.is_empty() {
            writeln!(file, "Example output:")?;
            write_output_to_file(file, output)?;
        } else {
            info!("empty stdout - nothing to write");
            if !&output.stderr.is_empty() {
                info!("stderr: {:#?}", String::from_utf8_lossy(&output.stderr));
            }
        }
    }
    Ok(())
}

fn write_output_to_file(file: &mut File, output: Output) -> io::Result<()> {
    writeln!(file, "```")?;
    file.write_all(&output.stdout)?;
    writeln!(file, "```")?;

    // if we want to keep this we could create 2 copies if you run this in a certain mode ("debug"
    // oder so) so you can see the stderr but in reality, we want dont want the errors in teh md
    // file and also probaly not write 'stdout', but just have <command><output> in a clean fashion
    if !&output.stderr.is_empty() {
        info!("stderr: {:#?}", String::from_utf8_lossy(&output.stderr));
    }
    Ok(())
}
